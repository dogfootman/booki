{
  "rules": [
    {
      "type": "prd",
      "content": "# 하와이 액티비티 여행사 운영 플랫폼 – MVP PRD\n\n## 1. 개요(Overview)\n하와이 현지 액티비티 여행사를 위한 SaaS 플랫폼. 에이전시 오너가 에이전트 스케줄·예약을 한 화면에서 관리하고, AI 최적화 및 SNS 자동 게시 기능으로 오버부킹과 마케팅 번거로움을 해소한다.\n\n## 2. 문제(Pain Point)\n1. 스케줄·예약 정보가 엑셀/카톡/이메일 등 여러 채널에 흩어져 중복 예약이 빈번\n2. SNS 홍보 글을 수작업으로 작성·업로드해야 해 시간 소모\n3. 에이전트별 업무 과부하를 실시간 파악하기 어려움\n\n## 3. 목표(Goals & KPIs)\n1. 오버부킹 건수 0건 유지 (첫 3개월)\n2. 예약 처리 시간 50% 단축 (기존 대비)\n3. SNS 게시글 작성·업로드 소요 시간 70% 절감\n4. 월 활성 여행사 5곳 확보 (6개월 내)\n\n## 4. 주요 사용자(Persona)\n- **에이전시 오너/매니저 – ‘Sarah’(35)**\n  - 하와이 호놀룰루 기반 소규모 액티비티 업체 운영(에이전트 10명)\n  - 한국·미국 고객 대상 양방향 예약 관리 필요\n  - 목표: 오버부킹 없는 일정 관리, 간편한 SNS 홍보, 매출 증대\n\n## 5. 핵심 기능(Scope – MVP)\n1. **에이전트 스케줄 관리 + AI 최적화**\n   - 캘린더 뷰(일/주/월)\n   - 에이전트별 근무 시간·휴무 설정\n   - AI 제안: 예약 분산 배치, 과부하 알림\n2. **고객 예약·결제 관리**\n   - 액티비티 상품 등록: 제목, 설명(다국어), 이미지, 가격, 시간대, 인원 제한\n   - 예약 생성·수정·취소, 잔여 슬롯 자동 계산\n   - Stripe 연동 USD 결제, 부분·전체 환불 처리\n3. **SNS 자동 게시(인스타그램 & 틱톡)**\n   - AI 문구·해시태그 자동 생성(한국어/영어)\n   - 게시 스케줄 지정 및 즉시 업로드\n   - 게시 기록·통계(좋아요·댓글 수) 조회\n4. **다국어 지원(한국어/영어)**\n   - UI 언어 전환, 다국어 콘텐츠 필드\n5. **관리자 대시보드**\n   - 오늘/이번 주 예약 현황, 에이전트 가용량, 매출 요약\n\n## 6. 비-기능 요구사항\n- Web Responsive (Desktop first, Tablet/Mobile 지원)\n- Performance: 주요 뷰 첫 로드 2초 이하\n- Security: GDPR & PCI-DSS 준수, HTTPS only\n- Accessibility: WCAG 2.1 AA 준수\n\n## 7. 지표(Success Metrics)\n- DAU / WAU\n- 예약당 평균 처리 시간\n- SNS 자동 게시 사용률\n- 오버부킹 발생 건수\n\n## 8. 출시 로드맵(Release Plan)\nM1 (4주): \n  • 프로젝트 세팅(Next.js15, Supabase) \n  • 에이전트·상품 CRUD API\nM2 (4주): \n  • 캘린더 UI, 예약 로직, 결제 연동\nM3 (4주): \n  • AI 스케줄 최적화, SNS 자동 게시 베타\nM4 (2주): \n  • 다국어 UI, Dashboard, QA & Beta Launch\n\n## 9. 경쟁사/벤치마킹\n- FareHarbor, Peek Pro – 예약/결제 집중\n- Later, Buffer – SNS 스케줄러\n=> 차별점: 두 영역을 하나의 워크플로로 통합 + AI 최적화\n\n## 10. 리스크 및 대응\n- Stripe 결제 불가 국가 ⇒ PayPal Backup\n- 인스타 API 변경 ⇒ 공식 파트너사 모듈 활용 & 모니터링\n\n## 11. 향후 확장(Out of Scope)\n- OTA 리뷰 연동, 실시간 다국어 채팅, 커미션 자동 정산\n\n---\n이 문서는 Vooster에 저장됩니다.",
      "writedAt": "2025-08-30T05:53:02.796Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구 사항 문서 (TRD)\n\n## 1. 기술 요약\n- **프로젝트 개요**: 하와이 액티비티 여행사를 위한 SaaS 플랫폼 개발. Next.js 15 기반의 반응형 웹 애플리케이션으로, 에이전트 스케줄 관리, 예약 관리, 결제, SNS 자동 게시, 다국어 지원, 관리자 대시보드 기능을 제공한다. AI 최적화는 예약 분산 및 과부하 알림에 활용된다.\n- **핵심 기술 스택**: Next.js 15, TypeScript, Tailwind CSS, Shadcn UI, Lucide React, @tanstack/react-query, date-fns, es-toolkit\n- **주요 기술 목표**: 2초 이내의 주요 뷰 첫 로드, GDPR & PCI-DSS 준수, WCAG 2.1 AA 준수, 오버부킹 0건 유지.\n- **주요 기술 가정**: Stripe 결제 연동의 안정성, SNS API의 지속적인 가용성, AI 모델의 초기 정확도.\n\n## 2. 기술 스택\n\n| 범주              | 기술 / 라이브러리        | 사유                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| ----------------- | --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 프레임워크          | Next.js 15                  | 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG), API 라우팅 지원으로 초기 로딩 속도 개선 및 SEO 최적화. TypeScript 지원으로 코드 안정성 확보.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| 언어              | TypeScript                  | JavaScript의 슈퍼셋으로, 정적 타입 검사를 통해 개발 생산성 향상 및 런타임 오류 감소. 코드 유지 보수성 향상.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| UI 프레임워크       | tailwindcss                 | 유틸리티 우선 CSS 프레임워크로, 빠른 UI 개발과 유지보수 용이성을 제공. 반응형 디자인을 쉽게 구현 가능.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| UI 컴포넌트 라이브러리 | shadcn                      | Tailwind CSS 기반의 재사용 가능한 UI 컴포넌트 제공. 일관된 디자인 시스템 유지 및 개발 속도 향상.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| 아이콘              | lucide-react                | 간결하고 아름다운 아이콘 제공. UI 일관성 유지.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| 데이터 페칭         | @tanstack/react-query      | 서버 상태 관리 및 데이터 페칭 라이브러리. 캐싱, 재시도, 폴링 등 다양한 기능을 제공하여 사용자 경험 향상.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| 날짜/시간 처리       | date-fns                    | JavaScript 날짜 및 시간 조작 라이브러리. 다양한 포맷 및 로케일 지원.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| 유틸리티 라이브러리    | es-toolkit                  | 다양한 유틸리티 함수 제공. (문자열 조작, 배열 처리 등)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 빌딩 블록\n\n*   **프론트엔드 (Frontend)**:\n    *   Next.js 15 기반의 사용자 인터페이스.\n    *   에이전트 스케줄 관리, 예약 관리, SNS 자동 게시 기능 제공.\n    *   Tailwind CSS, Shadcn UI, Lucide React를 사용하여 반응형 UI 구현.\n*   **백엔드 (Backend)**:\n    *   Next.js API 라우트를 사용하여 API 엔드포인트 제공.\n    *   데이터베이스와의 상호작용 처리.\n    *   Stripe 결제 연동, AI 스케줄 최적화, SNS 자동 게시 로직 구현.\n*   **데이터베이스 (Database)**:\n    *   (PRD에 Supabase 언급이 있으나, 명시적인 선택은 아님) 데이터베이스는 요구사항에 따라 선택 가능.\n    *   에이전트, 상품, 예약, 사용자 정보 저장.\n    *   PostgreSQL, MongoDB, Supabase 등의 옵션 고려.\n*   **외부 서비스 (External Services)**:\n    *   Stripe: 결제 처리.\n    *   SNS API (Instagram, TikTok): 자동 게시 기능.\n    *   AI 서비스 (미정): 스케줄 최적화.\n\n### 최상위 컴포넌트 상호작용 다이어그램\n\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] --> B[Backend (Next.js API)]\n    B --> C[Database (PostgreSQL/MongoDB/Supabase)]\n    B --> D[Stripe API]\n    B --> E[SNS API (Instagram, TikTok)]\n    B --> F[AI Service (미정)]\n```\n\n*   **Frontend (Next.js) -> Backend (Next.js API)**: 사용자 인터랙션에 따른 API 요청 및 응답 처리 (예: 예약 생성, 데이터 조회).\n*   **Backend (Next.js API) -> Database**: 데이터 저장, 조회, 수정, 삭제 작업 수행.\n*   **Backend (Next.js API) -> Stripe API**: 결제 요청 및 처리.\n*   **Backend (Next.js API) -> SNS API**: SNS 게시글 생성 및 업로드.\n*   **Backend (Next.js API) -> AI Service**: 스케줄 최적화 요청 및 결과 수신.\n\n### 코드 구성 및 컨벤션\n\n**도메인 기반 조직 전략**\n\n*   **도메인 분리**: 코드베이스를 비즈니스 도메인/바운디드 컨텍스트(예: 사용자 관리, 결제 처리, 콘텐츠 관리)별로 구성합니다.\n*   **계층 기반 아키텍처**: 문제를 별도의 계층(프레젠테이션, 비즈니스 로직, 데이터 액세스, 인프라)으로 분리합니다.\n*   **기능 기반 모듈**: 기술적 문제별로 분리하기보다는 관련 기능을 함께 그룹화합니다.\n*   **공유 컴포넌트**: 공통 유틸리티, 유형 및 재사용 가능한 컴포넌트를 전용 공유 모듈에 저장합니다.\n\n**범용 파일 및 폴더 구조**\n\n```\n/\n├── src/\n│   ├── app/                      # Next.js 라우트 및 페이지\n│   │   ├── api/                  # API 엔드포인트\n│   │   │   ├── agents/         # 에이전트 관련 API\n│   │   │   ├── activities/     # 액티비티 관련 API\n│   │   │   ├── bookings/       # 예약 관련 API\n│   │   │   └── ...\n│   │   ├── components/           # UI 컴포넌트\n│   │   │   ├── common/           # 재사용 가능한 컴포넌트\n│   │   │   ├── agents/         # 에이전트 관련 컴포넌트\n│   │   │   ├── activities/     # 액티비티 관련 컴포넌트\n│   │   │   ├── bookings/       # 예약 관련 컴포넌트\n│   │   │   └── ...\n│   │   ├── lib/                  # 유틸리티 함수 및 헬퍼\n│   │   │   ├── api-client.ts     # API 클라이언트\n│   │   │   ├── date-utils.ts     # 날짜 관련 유틸리티\n│   │   │   ├── ai-utils.ts       # AI 관련 유틸리티\n│   │   │   └── ...\n│   │   ├── types/                # TypeScript 타입 정의\n│   │   │   ├── agent.ts          # 에이전트 타입\n│   │   │   ├── activity.ts       # 액티비티 타입\n│   │   │   ├── booking.ts        # 예약 타입\n│   │   │   └── ...\n│   ├── styles/                 # CSS 스타일 (Tailwind CSS)\n│   │   ├── globals.css         # 전역 스타일\n│   │   └── ...\n├── public/                     # 정적 파일 (이미지, 폰트)\n├── next.config.js              # Next.js 설정 파일\n├── tsconfig.json               # TypeScript 설정 파일\n└── package.json                # 프로젝트 의존성 및 스크립트\n```\n\n### 데이터 흐름 및 통신 패턴\n\n*   **클라이언트-서버 통신**: API 요청/응답 패턴 (RESTful API).\n*   **데이터베이스 상호작용**: 데이터베이스에 직접 쿼리 또는 ORM (예: Prisma, TypeORM) 사용.\n*   **외부 서비스 통합**: API 키를 사용하여 외부 서비스 API (Stripe, SNS API)와 통합.\n*   **실시간 통신**: 필요시 WebSocket 또는 SSE (Server-Sent Events) 구현 (예: 예약 상태 업데이트 알림).\n*   **데이터 동기화**: 분산된 컴포넌트 간의 일관성 유지를 위한 패턴 적용 (예: 낙관적 업데이트).\n\n## 4. 성능 및 최적화 전략\n\n*   **코드 분할 (Code Splitting)**: Next.js의 동적 import를 사용하여 초기 로드 시 필요한 코드만 로드.\n*   **이미지 최적화**: Next.js의 Image 컴포넌트를 사용하여 이미지 크기 최적화 및 레이지 로딩 적용.\n*   **캐싱**: @tanstack/react-query를 사용하여 API 응답 캐싱.\n*   **데이터베이스 쿼리 최적화**: 필요한 데이터만 조회하도록 쿼리 작성, 인덱싱 활용.\n\n## 5. 구현 로드맵 및 마일스톤\n\n### 1단계: 기반 (MVP 구현)\n\n*   **핵심 인프라**: 프로젝트 설정 (Next.js 15, TypeScript, Tailwind CSS), 데이터베이스 설정.\n*   **필수 기능**: 에이전트 CRUD API, 상품 CRUD API, 로그인/회원가입.\n*   **기본 보안**: HTTPS 적용, 기본적인 입력 유효성 검사.\n*   **개발 환경**: 개발 환경 설정, CI/CD 파이프라인 구축.\n*   **예상 완료 기간**: 4주\n\n### 2단계: 기능 향상\n\n*   **고급 기능**: 캘린더 UI, 예약 로직, 결제 연동 (Stripe), SNS 자동 게시 (베타).\n*   **성능 최적화**: 코드 분할, 이미지 최적화, 캐싱 적용.\n*   **보안 강화**: GDPR & PCI-DSS 준수, XSS/CSRF 방어.\n*   **모니터링 구현**: 로그 수집 및 분석, 성능 모니터링.\n*   **예상 완료 기간**: 8주\n\n## 6. 위험 평가 및 완화 전략\n\n### 기술적 위험 분석\n\n*   **기술 위험**: AI 스케줄 최적화의 복잡성, SNS API 변경에 대한 의존성.\n*   **성능 위험**: 데이터 증가에 따른 성능 저하, 트래픽 증가에 따른 서버 부하.\n*   **보안 위험**: 결제 정보 유출, XSS/CSRF 공격.\n*   **통합 위험**: Stripe 결제 연동 실패, SNS API 장애.\n*   **완화 전략**:\n    *   AI 스케줄 최적화: 점진적인 기능 개발 및 테스트, 대체 알고리즘 준비.\n    *   SNS API 변경: 공식 파트너사 모듈 활용 및 API 변경 모니터링.\n    *   성능 저하: 코드 최적화, 캐싱, 데이터베이스 인덱싱.\n    *   서버 부하: 서버 확장, 로드 밸런싱.\n    *   보안 취약점: 정기적인 보안 점검 및 업데이트, 보안 코딩 가이드라인 준수.\n    *   Stripe 연동 실패: PayPal 백업 결제 시스템 구축.\n    *   SNS API 장애: 대체 SNS 플랫폼 연동 고려.\n\n### 프로젝트 배송 위험\n\n*   **일정 위험**: 개발 일정 지연, 외부 의존성 문제.\n*   **리소스 위험**: 개발팀 역량 부족, 핵심 개발자 이탈.\n*   **품질 위험**: 코드 품질 저하, 테스트 부족.\n*   **배포 위험**: 프로덕션 환경 문제, 배포 실패.\n*   **비상 계획**:\n    *   일정 지연: 핵심 기능 우선 개발, 일정 재조정.\n    *   리소스 부족: 추가 인력 확보, 외부 전문가 활용.\n    *   품질 저하: 코드 리뷰 강화, 자동화 테스트 도입.\n    *   배포 실패: 롤백 계획 수립, 모니터링 강화.\n",
      "writedAt": "2025-08-30T05:53:02.796Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-08-30T05:53:02.796Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-30T05:53:02.796Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-30T05:53:02.796Z"
    }
  ]
}